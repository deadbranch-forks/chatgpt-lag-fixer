## 2.2. The IntersectionObserver interface

The IntersectionObserver interface can be used to observe changes in the intersection of an intersection root and one or more target Elements.

The intersection root for an IntersectionObserver is the value of its root attribute if the attribute is non-null; otherwise, it is the top-level browsing context’s document node, referred to as the implicit root.

An IntersectionObserver with a non-null root is referred to as an explicit root observer, and it can observe any target Element that is a descendant of the root in the containing block chain. An IntersectionObserver with a null root is referred to as an implicit root observer. Valid targets for an implicit root observer include any Element in the top-level browsing context, as well as any Element in any nested browsing context which is in the list of the descendant browsing contexts of the top-level browsing context.

When dealing with implicit root observers, the API makes a distinction between a target whose relevant settings object’s origin is same origin-domain with the top-level origin, referred to as a same-origin-domain target; as opposed to a cross-origin-domain target. Any target of an explicit root observer is also a same-origin-domain target, since the target must be in the same document as the intersection root.

Note: In MutationObserver, the MutationObserverInit options are passed to observe() while in IntersectionObserver they are passed to the constructor. This is because for MutationObserver, each Node being observed could have a different set of attributes to filter for. For IntersectionObserver, developers may choose to use a single observer to track multiple targets using the same set of options; or they may use a different observer for each tracked target. rootMargin or threshold values for each target seems to introduce more complexity without solving additional use-cases. Per-observe() options could be provided in the future if the need arises.

```
[Exposed=Window]
interface IntersectionObserver {
  constructor(IntersectionObserverCallback callback, optional IntersectionObserverInit options = {});
  readonly attribute (Element or Document)? root;
  readonly attribute DOMString rootMargin;
  readonly attribute DOMString scrollMargin;
  readonly attribute FrozenArray<double> thresholds;
  readonly attribute long delay;
  readonly attribute boolean trackVisibility;
  undefined observe(Element target);
  undefined unobserve(Element target);
  undefined disconnect();
  sequence<IntersectionObserverEntry> takeRecords();
};
```

`new IntersectionObserver(callback, options)`

    Return the result of running the initialize a new IntersectionObserver algorithm, providing callback and options.
observe(target)

    Run the observe a target Element algorithm, providing this and target.
unobserve(target)

    Run the unobserve a target Element algorithm, providing this and target.

    Note: MutationObserver does not implement unobserve(). For IntersectionObserver, unobserve() addresses the lazy-loading use case. After loading is initiated for target, it does not need to be tracked. It would be more work to either disconnect() all targets and observe() the remaining ones, or create a separate IntersectionObserver for each target.
disconnect()

    For each target in this’s internal [[ObservationTargets]] slot:

        Remove the IntersectionObserverRegistration record whose observer property is equal to this from target’s internal [[RegisteredIntersectionObservers]] slot.

        Remove target from this’s internal [[ObservationTargets]] slot.

takeRecords()

        Let queue be a copy of this’s internal [[QueuedEntries]] slot.

        Clear this’s internal [[QueuedEntries]] slot.

        Return queue.

root, of type (Element or Document), readonly, nullable

    The root provided to the IntersectionObserver constructor, or null if none was provided.
rootMargin, of type DOMString, readonly

    Offsets applied to the root intersection rectangle, effectively growing or shrinking the box that is used to calculate intersections. These offsets are only applied when handling same-origin-domain targets; for cross-origin-domain targets they are ignored.

    On getting, return the result of serializing the elements of [[rootMargin]] space-separated, where pixel lengths serialize as the numeric value followed by "px", and percentages serialize as the numeric value followed by "%". Note that this is not guaranteed to be identical to the options.rootMargin passed to the IntersectionObserver constructor. If no rootMargin was passed to the IntersectionObserver constructor, the value of this attribute is "0px 0px 0px 0px".
scrollMargin, of type DOMString, readonly

    Offsets are applied to scrollports on the path from intersection root to target, effectively growing or shrinking the clip rects used to calculate intersections.

    On getting, return the result of serializing the elements of [[scrollMargin]] space-separated, where pixel lengths serialize as the numeric value followed by "px", and percentages serialize as the numeric value followed by "%". Note that this is not guaranteed to be identical to the options.scrollMargin passed to the IntersectionObserver constructor. If no scrollMargin was passed to the IntersectionObserver constructor, the value of this attribute is "0px 0px 0px 0px".
thresholds, of type FrozenArray<double>, readonly

    A list of thresholds, sorted in increasing numeric order, where each threshold is a ratio of intersection area to bounding box area of an observed target. Notifications for a target are generated when any of the thresholds are crossed for that target. If no options.threshold was provided to the IntersectionObserver constructor, or the sequence is empty, the value of this attribute will be [0].
delay, of type long, readonly

    A number indicating the minimum delay in milliseconds between notifications from this observer for a given target.
trackVisibility, of type boolean, readonly

    A boolean indicating whether this IntersectionObserver will track changes in a target’s visibility.

An Element is defined as having a content clip if its computed style has overflow properties that cause its content to be clipped to the element’s padding edge.

The root intersection rectangle for an IntersectionObserver is the rectangle we’ll use to check against the targets.

If the IntersectionObserver is an implicit root observer,
    it’s treated as if the root were the top-level browsing context’s document, according to the following rule for document. 
If the intersection root is a document,
    it’s the size of the document's viewport (note that this processing step can only be reached if the document is fully active). 
Otherwise, if the intersection root has a content clip,
    it’s the element’s padding area. 
Otherwise,
    it’s the result of getting the bounding box for the intersection root. 

When calculating the root intersection rectangle for a same-origin-domain target, the rectangle is then expanded according to the offsets in the IntersectionObserver’s [[rootMargin]] slot in a manner similar to CSS’s margin property, with the four values indicating the amount the top, right, bottom, and left edges, respectively, are offset by, with positive lengths indicating an outward offset. Percentages are resolved relative to the width of the undilated rectangle.

Note: rootMargin only applies to the intersection root itself. If a target Element is clipped by an ancestor other than the intersection root, that clipping is unaffected by rootMargin.

To apply scroll margin to a scrollport

    When calculating a scrollport intersection rectangle for a same-origin-domain target, the rectangle is expanded according to the offsets in the IntersectionObserver’s [[scrollMargin]] slot in a manner similar to CSS’s margin property, with the four values indicating the amount the top, right, bottom, and left edges, respectively, are offset by, with positive lengths indicating an outward offset. Percentages are resolved relative to the width of the undilated rectangle.

    These offsets are only applied when handling same-origin-domain targets; for cross-origin-domain targets they are ignored.

    Note: scrollMargin affects the clipping of target by all scrollable ancestors up to and including the intersection root. Both the scrollMargin and the rootMargin are applied to a scrollable intersection root’s rectangle.

Note: Root intersection rectangle and scrollport intersection rectangles are not affected by pinch zoom and will report the unadjusted viewport, consistent with the intent of pinch zooming (to act like a magnifying glass and NOT change layout.)

To parse a margin (root or scroll) from an input string marginString, returning either a list of 4 pixel lengths or percentages, or failure:

    Parse a list of component values marginString, storing the result as tokens.

    Remove all whitespace tokens from tokens.

    If the length of tokens is greater than 4, return failure.

    If there are zero elements in tokens, set tokens to ["0px"].

    Replace each token in tokens:

        If token is an absolute length dimension token, replace it with a an equivalent pixel length.

        If token is a <percentage> token, replace it with an equivalent percentage.

        Otherwise, return failure.

    If there is one element in tokens, append three duplicates of that element to tokens. Otherwise, if there are two elements are tokens, append a duplicate of each element to tokens. Otherwise, if there are three elements in tokens, append a duplicate of the second element to tokens.

    Return tokens.
